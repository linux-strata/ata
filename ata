#!/bin/sh -e

# prototype #2

export ATA_TREE="${ATA_TREE:-$HOME/code/ata/tree}"
export ATA_SRC_REPO="${ATA_SRC_REPO:-$HOME/code/ata/builds}"
export ATA_WORLDS="${ATA_WORLDS:-$HOME/code/ata/worlds}"

# currently, ata operates with a single repo and a single tree
# the directory in ATA_SRC_REPO contains source packages
# a source package currently is a directory named $name/$ver
# the directory must contain:
# an executable file named 'build'
# a newline seperated file named 'needs', where each line is a $name/$ver
# these packages will be symlinked into the package's /lib dir
# sources, which is a newline seperated set of source links
# this file format is not stable. it will change in future

# actions
# ata add pkg [ver]
# currently, ata builds packages directly into their install location
# this will change in future

# no dependency resolution at the moment 

p () {
    # p ( str... )
    printf "%s\n" "$@"
}

pd () {
    # pd ( str, [fd]:-1 )
    printf "%s\n" "$1" >&"${2:-1}"
}

log () {
    # log ( str... )
    pd "ata: $*" 2
}

err () {
    # err ( str... )
    log "$@"
    exit 1
}

dir_first () {
    # dir_first ( path )
    for file in "$1"/*;do
        p "${file#$1/}"
        return 0
    done
}

filename_from_url () {
    # filename_from_url ( url )
    old_ifs=$IFS
    IFS='/'
    set -f
    #shellcheck disable=SC2048,SC2086
    set -- $*
    
    for a in "$@"; do
        :
    done
    
    p "$a"
    set +f
    IFS=$old_ifs
}

nth_component () {
    # nth_component ( n string delim )
    # NB. negative N counted from end
    # 0 uninclusive
    n=$1
    string=$2
    old_ifs=$IFS
    IFS=${3:-/}
    set -f
    #shellcheck disable=SC2048,SC2086
    set -- $string
    
    shift $(( (n + $#) % $# ))
    
    p "$1"
    set +f
    IFS=$old_ifs
}

# this will be replaced with a checksum system in future

generate_checksums () {
    # generate_checksums ( sources )
    # runs in directory that is a package
    # outputs to stdout
    ver=$(filename_from_url "$PWD")
    pkg=$(nth_component -2 "$PWD")

    while read -r src _; do
        case $src in
            git*) 
                p "$src git git"
            ;;
            http[s]*)
                f=$(download_file "$src" "$pkg-$ver")
                
                c=$(sha256sum "$f")
                c=${c% *}
                log $c
                p "$src $c" 
            ;;
        esac
    done < "$1"
}

download_file () {
    # download_file( url, pkg-ver )
    # if http:
    # extract filename
    # 
    : "${XDG_CACHE_HOME:=$HOME/.local/cache}"
    
    dir="$XDG_CACHE_HOME/ata/$2"
    mkdir -p "$dir"

    log "URL: $1"
    case $1 in
        git://*)
            # git://git.com/repo@commit
            url=${1%@*}
            commit=${1#*@}
            destination=$(filename_from_url "$url")
            destination="${destination}@${commit}"
            if [ -d "${dir}/${destination}" ]; then
                log "$destination already cloned, skipping"
            else
                log "cloning $url"
                git clone --progress "$url" "$dir/$destination" >&2
                log "getting commit $commit"
                (cd "$dir/$destination"; git reset --hard "$commit") >&2
            fi
        ;;
        http[s]://*)
            destination=$(filename_from_url "$1")
            if [ -f "$dir/$destination" ]; then
                log "$destination already downloaded, skipping"
            else
                log "downloading $destination"
                curl "$1" -sSLo "$dir/$destination"
            fi
        ;;
        *://*)
            err "scheme in $1 not supported"
        ;;
        *)
            log "no scheme, assuming file"
            [ -f "$1" ] || err "$1 not file"
            destination=$1
        ;;
    esac
    p "$dir/$destination"
}

copy_to () {
    # copy_to ( path, dest )
    # download_file -> copy_to
  
    # if its an archive, extract it
    # if it's a directory, copy the files
    case $1 in
        *.tar*)
            # NB. not very robust checking: anything is a valid file extension
            # in practice, .tgz, .tbz2, etc can be found
            log "extracting $1"
            tar xf "$1" --strip-components 1 -C "$2"
            # NB. --strip-components is not always present
        ;;
        *)
            if [ -d "$1" ]; then
                log "copying dir $1"
                cp -r "$1/." "$2" 
            else
                log "copying file $1"
                cp -f "$1" "$2"
            fi
        ;;
    esac     
}

setup_build_dir () {
    # setup_build_dir ( dir )
    while read -r url dir; do
        extract_to=$build_dir
        f=$(download_file "$url" "$pkg-$ver")
        [ -z "$dir" ] || extract_to="$build_dir/$dir"
        mkdir -p "$extract_to"
        copy_to "$f" "$extract_to"
    done < "$ATA_SRC_REPO/$pkg/$ver/sources"
        
}


recursive_file_merge () {
    # recursive_file_merge ( source, destination )
    # create a recursive link between two directories.
    # mirror created directories, softlink files.
    (cd "$1"
        find . -type d -exec mkdir -p "$2/{}" \;
        find . -type l -exec ln -s "$1/{}" "$2/{}" \;
        find . -type f -exec ln -s "$1/{}" "$2/{}" \;
        # NB. doesn't handle conflicts
        
    )
}
main () {
    case $1 in
    build)
        shift 1
        pkg=${1:?no package name provided}
        ver=$2
        [ -d "$ATA_SRC_REPO"/"$pkg" ] || err "pkg $pkg invalid"
        [ -z "$ver" ] && ver=$(dir_first "$ATA_SRC_REPO/$pkg")
        [ -d "$ATA_SRC_REPO/$pkg/$ver" ] || err "$pkg/$ver: no such version"
        log "building $pkg/$ver"
        for f in build sources checksums; do
            [ -f "$ATA_SRC_REPO/$pkg/$ver/$f" ] || err "$pkg/$ver: no $f file"
        done
        
        log "comparing sources to checksums"
        generate_checksums ./sources | sort > "/tmp/checksum-$$"
        diff checksums "/tmp/checksum-$$" >/dev/null || err "generated checksums differ to sources"
        
        if [ -f "$ATA_SRC_REPO/$pkg/$ver/needs" ]; then
            mkdir -p "$ATA_TREE/$pkg/$ver/lib"
            while read -r dep; do
                [ -e "$ATA_TREE/$dep" ] || err "dependency $dep not found"
                for f in "$ATA_TREE/$dep"/usr/lib/*; do
                    # Reduce the size of RPATH
                    # see https://github.com/distr1/distri/commit/19f3
                    ln -sf "$f" "$ATA_TREE/$pkg/$ver/lib"
                done
                # CFLAGS need to be generated.
                CFLAGS="$CFLAGS -I$ATA_TREE/$dep/usr/include"
                PATH="$ATA_TREE/$dep/usr/include:$PATH"
                C_INCLUDE_PATH="$ATA_TREE/$dep/usr/include:$C_INCLUDE_PATH"
            done < "$ATA_SRC_REPO/$pkg/$ver/needs"
        fi
        
        if [ "$pkg" != musl-cross-make ]; then 
            export CC=x86_64-linux-musl-cc
            export CXX=x86_64-linux-musl-c++
            
            export PATH="$ATA_TREE/musl-cross-make/0.9.10/usr/bin:$PATH"
            CFLAGS="-L$ATA_TREE/$pkg/$ver/lib $CFLAGS"
            export LDFLAGS="-L$ATA_TREE/$pkg/$ver/lib -Wl,-rpath,$ATA_TREE/$pkg/$ver/lib -Wl,-dynamic-linker,$ATA_TREE/musl-cross-make/0.9.10/usr/lib/ld-musl-x86_64.so.1"
        fi
        
        build_dir=/tmp/ata-build-$$
        mkdir -p "$build_dir"
        log "setting up build in $build_dir"
        setup_build_dir "$build_dir"
        cd "$build_dir"
        
        time1=$(date +%s)
        log "starting build"
        env -i CC="$CC" CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS" PATH="$PATH" ATA_TREE="$ATA_TREE" MAKEFLAGS="${MAKEFLAGS:--j10}" LD_LIBRARY_PATH="$LD_LIBRARY_PATH" C_INCLUDE_PATH="${C_INCLUDE_PATH%:}" "$ATA_SRC_REPO/$pkg/$ver/build" null "$pkg" "$ver"
        time2=$(date +%s)
        s=$((time2 - time1))
        log "build completed in ${s}s"
    ;;
    checksums)
        [ -e sources ] || err "sources file required to generate checksums"   
        [ -e checksums ] && log "checksums file exists, re-generating"
        generate_checksums ./sources | sort > checksums
    ;;
    world)
        shift 1
        # ata worlds are identified by a sha256 of their sorted worldfile, for now
        # ata worlds are a /usr created from symlinking the contents several packages together
        # this may, in future, be implemented via FUSE.
        # worlds can be found in $ATA_WORLDS
        # no dependency resolution is needed
        case $1 in
            build)
                shift 1
                [ -z "$1" ] && err "missing worldfile argument"
                id=$(sort -u "$1" | sha256sum)
                id=${id%% *}
                if [ ! -d "$ATA_WORLDS/$id" ]; then
                    log "building world $id"
                    base="$ATA_WORLDS/$id"
                    while read -r pkg; do
                        [ -d "$ATA_TREE/$pkg" ] || err "$pkg not found"
                        log "merging $pkg"
                        recursive_file_merge "$ATA_TREE/$pkg/usr" "$base"
                    done < "$1"
                    log "world $id created"
                else
                    log "world $id exists, skipping"
                fi
            ;;
            env)
                shift 1
                [ -z "$1" ] && err "missing worldfile argument"
                cmd=$2
                : "${cmd:=sh}"
                main world build "$1"
                # shell doesn't scope variables
                env -i PATH="$ATA_WORLDS/$id/bin" "$ATA_WORLDS/$id/bin/$cmd"
            ;;
        esac
    ;;
    *)
        err "$1 not implemented"
    ;;
    esac
}
main "$@"
