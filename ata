#!/bin/sh -e

# prototype #2

export ATA_TREE="${ATA_TREE:-$HOME/code/ata/tree}"
export ATA_SRC_REPO="${ATA_SRC_REPO:-$HOME/code/ata/builds}"

# currently, ata operates with a single repo and a single tree
# the directory in ATA_SRC_REPO contains source packages
# a source package currently is a directory named $name/$ver
# the directory must contain:
# an executable file named 'build'
# a newline seperated file named 'needs', where each line is a $name/$ver
# these packages will be symlinked into the package's /lib dir
# sources, which is a newline seperated set of source links
# this file format is not stable. it will change in future

# actions
# ata add pkg [ver]
# currently, ata builds packages directly into their install location
# this will change in future

# no dependency resolution at the moment 

p () {
    printf "%s\n" "$@"
}

pd () {
  printf "%s\n" "$1" >&"${2:-1}"
}

err () {
    pd "ata: $@" 2
    exit 1
}

dir_first () {
    for file in "$1"/*;do
        p "${file#$1/}"
        return 0
    done
}

filename_from_url () {
    old_ifs=$IFS
    IFS='/'
    set -f
    set -- $*
    
    for a in "$@"; do
        :
    done
    
    p "$a"
    set +f
    IFS=$old_ifs
}

# this will be replaced with a checksum system in future

download_file () {
    : "${XDG_CACHE_HOME:=$HOME/.local/cache}"
    dir="$XDG_CACHE_HOME/ata/$2"
    mkdir -p "$dir"
    if [ -e "$dir/$3" ]; then
        pd "$3 cached" 2
    else
        curl "$1" -sSo "$dir/$3"
    fi
    p "$dir/$3"
}

main () {
    case $1 in
    build)
        shift 1
        pkg=${1:?no package name provided}
        ver=$2
        [ -d "$ATA_SRC_REPO"/"$pkg" ] || err "pkg $pkg invalid"
        [ -z "$ver" ] && ver=$(dir_first "$ATA_SRC_REPO/$pkg")
        [ -d "$ATA_SRC_REPO/$pkg/$ver" ] || err "$pkg/$ver: no such version"
        
        for f in build sources; do
            [ -f "$ATA_SRC_REPO/$pkg/$ver/$f" ] || err "$pkg/$ver: no $f file"
        done
        build_dir=/tmp/ata-build-$$
        mkdir -p "$build_dir"
        
        while read -r url; do
            f=$(download_file "$url" "$pkg-$ver" "$(filename_from_url $url)")
            tar xf "$f" --strip-components 1 -C "$build_dir"
        done < "$ATA_SRC_REPO/$pkg/$ver/sources"
        
        cp "$ATA_SRC_REPO/$pkg/$ver"/build "$build_dir"
        
        CFLAGS="-nostdinc -nostdlib -nodefaultlibs -Wl,-rpath=$ATA_TREE/$pkg/$ver/lib -L$ATA_TREE/$pkg/$ver/lib"
        LD_LIBRARY_PATH="$ATA_TREE/$pkg/$ver/lib"
        LDFLAGS="--verbose -nostdlib -nodefaultlibs -L$ATA_TREE/$pkg/$ver/lib -dynamic-linker $ATA_TREE/musl/1.2.5/usr/lib/ld-musl-x86_64.so.1"
        
        if [ -f "$ATA_SRC_REPO/$pkg/$ver/needs" ]; then
            mkdir -p "$ATA_TREE/$pkg/$ver/lib"
            while read -r dep; do
                for f in "$ATA_TREE/$dep"/usr/lib/*; do
                    # Reduce the size of RPATH, and cause 
                    ln -sf "$f" "$ATA_TREE/$pkg/$ver/lib"
                done
                # CFLAGS need to be generated.
                CFLAGS="$CFLAGS -I$ATA_TREE/$dep/usr/include"
                C_INCLUDE_PATH="$ATA_TREE/$dep/usr/include:$C_INCLUDE_PATH"
            done < "$ATA_SRC_REPO/$pkg/$ver/needs"
        fi
        
        cd "$build_dir"
        p '*link_libgcc:' > /tmp/ata-gcc.specs
        p "-L$ATA_TREE/$pkg/$ver/lib" >> /tmp/ata-gcc.specs
        
        env -i CFLAGS="$CFLAGS -specs=/tmp/ata-gcc.specs" PATH=$PATH ATA_TREE=$ATA_TREE LD_LIBRARY_PATH=$LD_LIBRARY_PATH C_INCLUDE_PATH=$C_INCLUDE_PATH ./build null "$pkg" "$ver"
    ;;
    *)
        err "$1 not implemented"
    ;; 
    esac
}
main "$@" 

