#!/ata/pkg/oils-0.26.0/usr/bin/ysh

# prototype #3

# currently, ata operates with a single repo and a single tree
# the directory in ATA_SRC_REPO contains source packages
# a source package currently is a txtar archive representing a directory
# the directory must contain:
# an executable file named 'build'
# a newline seperated file named 'needs', where each line is a $name-$ver
# the 'needs' files must contain two special directives:
# libc:$pkgname
# toolchain:$pkgname
# these will configure the toolchain and libc used in building the package
# a package specified by libc: must contain a file named `libc` containing the path
# to the dynamic linker
# a package specified by toolchain: must have a file named `toolchain` containing the triplet
# these packages will be symlinked into the package's /lib dir
# sources, which is a newline seperated set of source links
# this file format is not stable. it will change in future

# srcpkgfile

# no dependency resolution at the moment 


nl='
'

p () {
    # p ( str... )
    write -- "$@"
}

pd () {
    # pd ( str, [fd]:-1 )
    write -- "$1" >&"${2:-1}"
}

log () {
    # log ( str... )
    pd "ata: $*" 2
}

err () {
    # err ( str... )
    log "$@"
    exit 1
}

func W(list) {
    if (type(list) === "Str") {
        return ([list])
    }
    return (list)
}

func default(d, k, v) {
    if (get(d, k) === null) {
        setvar d[k] = v
    }
    return (d)
}

var ATA_TREE = "/ata/pkg" # For now, this one isn't alterable.

call default (ENV, "ATA_SRC_REPO", /ata/src/builds)
call default (ENV, XDG_CACHE_HOME, $HOME/.local/cache)
call default (ENV, "DESTDIR", "")
call default (ENV, "ATA_WORLDS", "/ata/worlds")
call default (ENV, "ATA_SKIP_REBUILD", 1)

setglobal SRCPKG_SUFFIX = ".txtar"

proc usage () {
    cat << 'EOF'
usage: ata <command> [<args>]

The following commands are currently supported:
    build     <pkg> [<version>]    Compile a binary package from source
    install   <pkg> [<version>]    Install a compiled package
    checksums <pkg> [<version>]    Generate checksums of a package's sources
    world build  <worldfile>       Construct an ata world from a worldfile
    world env    <worldfile>       Enter an environment specified by a worldfile
EOF
}

proc filename_from_url (url) {
    nth_component -1 $url "/"
}

proc nth_component (n, string, delim=" ") {
    p $[string.split (delim)[n]]
}

func shape(list, n, fill=null) {
    if (n > len(list)) {
        for _ in (len(list) ..< n) {
            call list->append(fill)
        }
    }
    return (list)
}


func sdd(d,k,b) { # the same as above, but with string defaults: 'String Dict Default'
    if (get(d, k) === null) {
        setvar d[k] = b
    } else {
        setvar d[k] = (d[k]++b)
    }
    return (d)
}

file_equal () {
    # file_equal ( file1, file2 ) 
    diff "$1" "$2" >/dev/null 2>&1

}

recursive_file_merge () {
    # recursive_file_merge ( source, destination, [DESTDIR] )
    # create a recursive link between two directories.
    # mirror created directories, softlink files.
    find "$3/$1" | while read -r abs; do
        rel=${abs#"$3/$1"}
        if [ -L "$abs" ]; then
            ln -sf "$1$rel" "$3$2$rel"
        else
            [ -d "$abs" ] && mkdir -p "$3/$2/$rel"
            [ -f "$abs" ] && ln -sf "$1$rel" "$3$2$rel"
        fi
    done
    # NB. doesn't handle conflicts
}

is_dynamic () {
    # is_dynamic ( file )
    
    case $(readelf -d "$1" 2>&1 | tail -n1) in
        *"no dynamic"*)
            return 1 ;;
        *"Not an ELF"*)
            return 1 ;;
        *)
            return 0 ;;
    esac
}

# usage: read --all < ./xyz.txtar
# txtar_read(_reply.split(u'\n'))
# or, to get the contents of filename
# txtar_read(_reply.split(u'\n'), filename) 
func txtar_read (lines, select="") {
    var archive = {}
    var file = ""
    var body = false
    for line in (lines) {
        if (line ~ /'-- '.+' --'/) {
            setvar file = line => trim(/' '? '--' ' '?/) => trim()
            setvar archive[file] = []
            setvar body = true
        } else {
            $body || continue
            setvar archive[file] = archive[file] ++ [line]            
        }
    }
    if (select) {
        return (archive[select])
    }
    return (archive)
    
}

# takes the input of txtar_read, and unpacks it into CWD
proc txtar_unpack (;txtar) {
    for filename, file in (txtar) {
        if (filename ~ /.+'/'.+/ ) {
            mkdir -p ${filename%%/*}
        }
        : > $filename
        
        write -- @[W(file)] > $filename  
    }
}

# returns a path to a txtar file
proc find_pkg (;path, build) {
    var b
    read --all < $[ :| $[ENV.ATA_SRC_REPO]/$path-*.txtar|[0] ]
    setvar b = txtar_read(_reply.split(u'\n'))
    setvar b["name"] = path => trim(".txtar") => trimStart(/ .+'/' /) ++ "-" ++ W(b.version)[0]
    setvar b["path"] = :| $[ENV.ATA_SRC_REPO]/$path-*.txtar |[0] 
    for file in build needs version {
        if (get(b, file) === "") {
            err "invalid package: missing $file"
        }
    }
    call build->setValue(b)
}


copy_to () {
    # copy_to ( path, dest )
    # download_file -> copy_to
  
    # if its an archive, extract it
    # if it's a directory, copy the files
    log $1 $2
    case $1 in
        *.tar*|*.t*)
            # NB. not very robust checking: anything is a valid file extension
            # in practice, .tgz, .tbz2, etc can be found
            log "extracting $1"
            tar xf "$1" --strip-components 1 -C "$2"
            # NB. --strip-components is not always present
        ;;
        *)
            if test -d "$1"; then
                log "copying dir $1"
                cp -r "$1/." "$2" 
            else
                log "copying file $1"
                cp -f "$1" "$2"
            fi
        ;;
    esac
}

proc generate_checksum (path) {
    # outputs to stdout
    case $path in
        git*) 
            p "git"
        ;;
        *)
            var c = $(sha256sum "$path") 
            p "${c%  *}"
        ;;
    esac
}


proc download_file (;url, build, destination="") {
    var dir="$[ENV.XDG_CACHE_HOME]/ata/$[build.name]/src"
    mkdir -p "$dir"

    log "URL: $url"
    case $url in
        git:*)
            # git:https://git.com/repo@commit
            setvar url = ${url%@*}
            setvar url = ${url#git:}
            var commit = ${url#*@}
            setvar destination = $(filename_from_url "$url")
            setvar destination = "${destination}@${commit}"
            if test -d "${dir}/${destination}" ; then
                log "$destination already cloned, skipping"
            else
                log "cloning $url"
                git clone --progress "$url" "$dir/$destination" >&2
                log "getting commit $commit"
                (cd "$dir/$destination"; git reset --hard "$commit") >&2
            fi
        ;;
        http[s]://*)
            if (destination === "") {
                setvar destination = $(filename_from_url "$url")
            }
            if test -f "$dir/$destination" ; then
                log "$destination already downloaded, skipping"
            else
                log "downloading $destination"
                curl "$url" -sSLo "$dir/$destination"
            fi
        ;;
        *://*)
            err "scheme in $url not supported"
        ;;
        *)
            log "no scheme, assuming file"
            
            setvar destination = "$url"
            setvar dir=""
        ;;
    esac
    p "$dir/$destination"
}



proc construct_compiler_flags (;build) {
    var rpath = "$ATA_TREE/$[build["name"]]/lib" # TODO: implement a more general solution
    var flags = "-L$rpath -Wl,-rpath,$rpath -Wl,-rpath-link,$rpath "
    # We shove this set of flags in everything, with the hopes that something will listen.
    # Some things respect LDFLAGS, but not CFLAGS. For others, it's the other way around.
    # There's no guaranteeing how these flags will be used, so it's important to get
    # this set into everything.
    
    # It should be unset at this point. Best be safe, though.
    call default(build, 'env', {}) \
        => sdd('CFLAGS',   flags) \
        => sdd('CXXFLAGS', flags) \
        => sdd('LDFLAGS',  flags)
    parse_needs (build)
}


proc parse_needs (;build) {
    mkdir -p "$ATA_TREE/$[build.name]/lib" # Annoying, but neccessary.
    # But, not for long.
    # We can bind-mount into a tmpfs and then unshare-chroot into it, creating an isolated environment.
    var dep = ""
    # Parser for the 'needs' format.
    for line in (build.needs) {
        if (line === "") { continue }
        
        var line = line => split(":")

        if (len(line) > 1) {
            setvar dep = line->pop()
        } else {
            setvar dep = line[0] # for consistency's sake
            setvar line = ["path"]
            
        }
        # This will later support `libc, toolchain:`, but doesn't at present.
        for mod in (line) {
            case (mod) {
                libc {
                    if ("${libc:-}" !== '') {
                        err "libc set twice in $[build['name']]"
                    }
                    read --all < "$[ENV.ATA_SRC_REPO]/$dep.txtar" 
                    # I should be able to use find_pkg for this.
                    var libc = txtar_read(_reply.split(u'\n'))
                    if (libc.libc === null) {
                        err "$dep, specified as libc, has no 'libc' file"
                    }
                    setvar libc = libc.libc[0]
                        
                    call build.env \
                    => sdd('CFLAGS',
                      "-Wl,-dynamic-linker,$ATA_TREE/$1/usr/lib/$libc " ++ \
                      "-isystem $ATA_TREE/$dep/usr/include "
                    ) \
                    => sdd(
                      'LDFLAGS',
                      "-Wl,-dynamic-linker,$ATA_TREE/$dep/usr/lib/$libc "
                    ) \
                    => sdd( \
                       'CXXFLAGS',   \
                       "-Wl,-dynamic-linker,$ATA_TREE/$dep/usr/lib/$libc "
                    )
                    
                }&
                lib {
                    call build.env \
                    => sdd('C_INCLUDE_PATH', "$ATA_TREE/$dep/usr/include:") \
                    => sdd('CFLAGS', "-I$ATA_TREE/$dep/usr/include ") \
                    => sdd('PKG_CONFIG_PATH', "$ATA_TREE/$dep/usr/lib/pkgconfig:")
                    # This will be removed in isolated builds.
                    
                    for f in "$ATA_TREE/$dep"/usr/lib/* {
                        [ -e "$f" ] || continue
                        log $f
                        ln -sf "$f" "$ATA_TREE/$[build.name]/lib"
                    }
                }
                toolchain {
                    if ("${toolchain:-}" !== '') {
                        err "toolchain set twice in $[build['name']]"
                    }
                    read --all < "$[ENV.ATA_SRC_REPO]/$dep.txtar" 
                    # I should be able to use find_pkg for this.
                    var toolchain = txtar_read(_reply.split(u'\n'))
                    if (toolchain === null) {
                        err "$dep, specified as toolchain, has no 'toolchain' file"
                    }
                    setvar toolchain = toolchain.toolchain[0] 
                    call build.env \
                    => sdd('CC',   "$toolchain-cc") \
                    => sdd('CXX',  "$toolchain-c++") \
                    => sdd('PATH', "$ATA_TREE/$dep/usr/bin:")
                }
                lib {
                    call build.env \
                    => sdd('C_INCLUDE_PATH', "$ATA_TREE/$dep/usr/include:") \
                    => sdd('CFLAGS', "-I$ATA_TREE/$dep/usr/include ") \
                    => sdd('PKG_CONFIG_PATH', "$ATA_TREE/$dep/usr/lib/pkgconfig:")
                    # This will be removed in isolated builds.
                    
                    for f in "$ATA_TREE/$dep"/usr/lib/* {
                        [ -e "$f" ] || continue
                        log $f
                        ln -sf "$f" "$ATA_TREE/$[build.name]/lib"
                    }
                }
                path {
                    # unadorned packages are added to $PATH
                    call sdd(build.env, 'PATH', "$ATA_TREE/$dep/usr/bin:")
                }
            }
        }
    }
}

proc setup_build_dir (;build) {
    setvar build.builddir = "$tmp_base/build"
    mkdir -p $[build.builddir]
    setvar build.destdir = "$tmp_base/dest"
    mkdir -p $[build.destdir]
    
    log "setting up build in $[build.builddir]"
    
    cd $[build.builddir]
    for line in (build.sources) {
        var x = line.split(" ") => shape(3, "")
        var url = x[0]
        var checksum = x[1]
        var dest = x[2]
        var extract_to = "$[build.builddir]/${dest:-}"
        var f = $(download_file (url, build, dest))
        var h = $(generate_checksum "$f")
        test "$h" = "$checksum" || err "expected checksum '$checksum', got '$h'"
        mkdir -p "$extract_to"
        copy_to "$f" "$extract_to"
    }
    

}

proc create_binary (;build) {
    var dir="$[ENV.XDG_CACHE_HOME]/ata/$[build.name]/built"
    mkdir -p "$dir"
    cd "$[build.destdir]/$ATA_TREE/$[build.name]"
    tar czf "$dir/ata-built-$[build.name].tar.gz" .
}

tmp_cleanup () {
    if ("$tmp_base" !== "" and get(ENV, "ATA_DEBUG") !== "") {
        rm -rf "$tmp_base"
    }
}

main () {
    setglobal tmp_base = $(mktemp -dt ata-$$-XXXXXXXX)
    trap tmp_cleanup INT
    trap tmp_cleanup EXIT
    var build = {}
    if (len(ARGV) < 1) {
        usage
        err "requires at least one argument"
    }
    case $[ARGV[0]] in
    usage)
        usage
    ;;
    build)
        shift 1
        find_pkg (ARGV[1], &build)

        p "building $[build.name]"
        
        var pkg_dir = "$tmp_base/pkgdir"
        mkdir -p $pkg_dir
        cd $pkg_dir { txtar_unpack (build) }
        
        chmod +x "$pkg_dir/build"
        
        construct_compiler_flags (build)
        setup_build_dir (build)

        time1=$(date +%s)
        log "starting build in $[build.builddir]"
        
        var env = []
        for k, v in (build.env) {
            call env->append("${k}=$[v.trimEnd(':')]")
        }
        cd "$tmp_base/build" {
            env -i @env \
                _prefix="$ATA_TREE/$[build.name]/usr" \
                "$pkg_dir/build" "$[build.destdir]" "$[build.name]"
        }
            
        mkdir -p "$[build.destdir]/$ATA_TREE/$[build.name]"
        cp -r "$[build.path]" "$[build.destdir]/$ATA_TREE/$[build.name]"
        var time2 = $(date +%s)
        var s = time2 - time1 
        log "build completed in ${s}s"
        create_binary (build)
    ;;
    scaffold)
        # Creates an empty ata package
        # Takes a name, version, and a source url, and generates an empty package in this directory.
        shift 1
        name=${1:?no name provided}
        version=${2:?no version provided}
        pkgname="$name-$version"
        if [ "$3" ]; then
            checksum="$3 $(generate_checksum $3)" 
        fi
        [ -e "$pkgname.txtar" ] && err "package $pkgname already exists here"
        cat << EOF > "$pkgname.txtar"
-- build --
#!/bin/sh -e
-- sources --
$checksum
-- version --
$version
-- needs --
EOF
    ;;
    checksum)
        exit 1
        shift 1 
        find_pkg "$1"
        shift 1
        generate_checksum "$1"
    ;;
    install)
        shift 1
        find_pkg (ARGV[1], &build)
    
        var pkgf = "$[ENV.XDG_CACHE_HOME]/ata/$[build.name]/built/ata-built-$[build.name].tar.gz"
        
        if ! test -e "$pkgf" || [ "$ATA_SKIP_REBUILD" != 1 ]; then
            log "archive $pkgf not found, building"
            main build "$[build.name]"
        fi
        test -e "$pkgf" || err "archive $pkgf not created"
        log "found archive for $[build.name]: $pkgf"
        mkdir -p "$DESTDIR/$ATA_TREE/$[build.name]"
        log "installing to $DESTDIR$ATA_TREE/$[build.name]"
        tar xzf "$pkgf" -C "$DESTDIR/$ATA_TREE/$[build.name]"
        log "installed $[build.name]"
        
    ;;
    resolve)
        shift 1
        find_pkg "$1"
        p "$ATA_TREE/$pkgname"
    ;;
    world)
        shift 1
        # ata worlds are identified by a sha256 of their sorted worldfile, for now
        # ata worlds are a /usr created from symlinking the contents several packages together
        # this may, in future, be implemented via FUSE.
        # worlds can be found in $ATA_WORLDS
        # no dependency resolution is needed
        case $1 in
            build)
                shift 1
                [ -z "$1" ] && err "missing worldfile argument"
                id=$(sort -u "$1" | sha256sum)
                id=${id%% *}
                if [ ! -d "$DESTDIR/$ATA_WORLDS/$id" ]; then
                    log "building world $id"
                    base="$ATA_WORLDS/$id"
                    mkdir -p "$DESTDIR/$base"
                    log "merging into $DESTDIR$base"
                    while read -r pkg; do
                        #[ -d "$DESTDIR/$ATA_TREE/$pkg" ] || err "$pkg not found"
                        log "merging $pkg from $1"
                        recursive_file_merge "$ATA_TREE/$pkg/usr" "$base" "$DESTDIR"
                        
                    done < "$1"
                    log "world $id created"
                else
                    log "world $id exists, skipping"
                fi
            ;;
            env)
                shift 1
                [ -z "$1" ] && err "missing worldfile argument"
                cmd=$2
                : "${cmd:=sh}"
                main world build "$1"
                # shell doesn't scope variables
                env -i PATH="$ATA_WORLDS/$id/bin" "$ATA_WORLDS/$id/bin/$cmd"
            ;;
        esac
    ;;
    *)
        usage
        err "command $1 not implemented"
    ;;
    esac
}
main "$@"
